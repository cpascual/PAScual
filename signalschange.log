--- /home/carlos/src/PAScual/PAScual/ChkUpdt.py	(original)
+++ /home/carlos/src/PAScual/PAScual/ChkUpdt.py	(refactored)
@@ -40,10 +40,9 @@
         self.daysSB.setValue(__DEFAULTCHECKINTERVAL__)
         self.buttonBox = QDialogButtonBox(
             QDialogButtonBox.Yes | QDialogButtonBox.No)
-        QObject.connect(self.buttonBox, SIGNAL("accepted()"),
-                        self.check_for_Updates)
-        QObject.connect(self.buttonBox, SIGNAL("rejected()"), self.reject)
-        QObject.connect(self, SIGNAL("finished(int)"), self.onClose)
+        self.buttonBox.accepted.connect(self.check_for_Updates)
+        self.buttonBox.rejected.connect(self.reject)
+        self.finished.connect(self.onClose)
         layout2 = QHBoxLayout()
         layout2.addWidget(QLabel("(you will be reminded again in "))
         layout2.addWidget(self.daysSB)
--- /home/carlos/src/PAScual/PAScual/CommandsTableMV.py	(original)
+++ /home/carlos/src/PAScual/PAScual/CommandsTableMV.py	(refactored)
@@ -121,7 +121,7 @@
                              value=QVariant(QString()))  # clear the args
             elif column == ARGS:
                 self.commands[row].args = value
-            self.emit(SIGNAL("dataChanged(QModelIndex,QModelIndex)"), index,
+            self.dataChanged.emit(index,
                       index)
             return True
         return False
@@ -239,9 +239,9 @@
         mainLayout.addWidget(self.allBT, 3, 1)
         self.setLayout(mainLayout)
 
-        QObject.connect(self.addBT, SIGNAL("clicked()"), self.onAdd)
-        QObject.connect(self.remBT, SIGNAL("clicked()"), self.onRem)
-        QObject.connect(self.dataBT, SIGNAL("clicked()"), self.onData)
+        self.addBT.clicked.connect(self.onAdd)
+        self.remBT.clicked.connect(self.onRem)
+        self.dataBT.clicked.connect(self.onData)
         # 		QObject.connect(self.allBT,SIGNAL("clicked()"),self.model.checkAll)
         self.table.resizeColumnsToContents()
         # 		self.tree.resizeColumnsToContents()
--- /home/carlos/src/PAScual/PAScual/ComponentTableMV.py	(original)
+++ /home/carlos/src/PAScual/PAScual/ComponentTableMV.py	(refactored)
@@ -176,13 +176,12 @@
                 fp.free = not fp.free
                 for i in [COMMON, MINVAL, MAXVAL]:
                     otherindex = QAbstractTableModel.index(self, index.row(), i)
-                    self.emit(SIGNAL("dataChanged(QModelIndex,QModelIndex)"),
-                              otherindex,
+                    self.dataChanged.emit(otherindex,
                               otherindex)  # note: a similar thing can be used to update the whole row
             elif column == COMMON:
                 fp.common = not fp.common
             # 			print fp.showreport()
-            self.emit(SIGNAL("dataChanged(QModelIndex,QModelIndex)"), index,
+            self.dataChanged.emit(index,
                       index)
             return True
         return False
@@ -232,11 +231,10 @@
         mainLayout.addWidget(self.tauorityBT)
         self.setLayout(mainLayout)
 
-        QObject.connect(self.addBT, SIGNAL("clicked()"), self.onAdd)
-        QObject.connect(self.remBT, SIGNAL("clicked()"), self.onRem)
-        QObject.connect(self.tauorityBT, SIGNAL("toggled(bool)"),
-                        self.onTItoggled)
-        QObject.connect(self.dumpBT, SIGNAL("clicked()"), self.showreport)
+        self.addBT.clicked.connect(self.onAdd)
+        self.remBT.clicked.connect(self.onRem)
+        self.tauorityBT.toggled.connect(self.onTItoggled)
+        self.dumpBT.clicked.connect(self.showreport)
 
     def onAdd(self):
         self.model.insertRows(position=self.posSB.value(),
--- /home/carlos/src/PAScual/PAScual/PASCommandProcess.py	(original)
+++ /home/carlos/src/PAScual/PAScual/PASCommandProcess.py	(refactored)
@@ -63,7 +63,7 @@
     def run(self):
         self.launchFit(self.ps)
         self.stop()
-        self.emit(SIGNAL("endrun(bool)"), self.completed)
+        self.endrun.emit(self.completed)
 
     def launchFit(self, ps):
         '''This launches the fit (called via the run method). For the given palsset, it interpretes the commands and calls the appropriate functions'''
@@ -151,6 +151,6 @@
             # flush the output
             if self.outputfile: self.outputfile.flush()
             # emit a signal of command done
-            self.emit(SIGNAL("command_done(int)"), icmd + 1)
+            self.command_done.emit(icmd + 1)
         if self.isStopped(): return  # This makes possible to respond to a request of stopping the fit
         self.completed = True
--- /home/carlos/src/PAScual/PAScual/PAScual.py	(original)
+++ /home/carlos/src/PAScual/PAScual/PAScual.py	(refactored)
@@ -105,8 +105,7 @@
 		That is, to redirect all stdout to a list of file objects'''
         for fileobject in self.fileobjects:
             fileobject.write(string)
-        if self.emitEnabled: emitter.emit(SIGNAL('teeOutput'),
-                                          copy.deepcopy(string))
+        if self.emitEnabled: emitter.teeOutput.emit(copy.deepcopy(string))
 
     def flush(self):
         for fileobject in self.fileobjects: fileobject.flush()
@@ -1124,8 +1123,7 @@
                     ireport = nreport  # reset count
                 #					self.graph_report()
                 if (iemit == 0):
-                    emitter.emit(SIGNAL("commandPBarValue(int)"),
-                                 acc)  # signal for updating the progress bar
+                    emitter.commandPBarValue.emit(acc)  # signal for updating the progress bar
                     iemit = nemit
             else:
                 self.undo()
@@ -1235,7 +1233,7 @@
             print 'SimAnn: initial acc. ratio too low. Increasing T to %.2g' % T
             if abort.abortRequested(): return  # check if we should abort
         # The SA loop
-        emitter.emit(SIGNAL("initCommandPBar(int,int)"), int(-S.log(T)), int(
+        emitter.initCommandPBar.emit(int(-S.log(T)), int(
             -S.log(stopT)))  # signal for setting up the progress bar
         while not endflag:
             self.MCMC_generate(LM=LM, T=T, ireport=LM, NNRLA='auto',
@@ -1243,8 +1241,7 @@
             if abort.abortRequested(): return  # check if we should abort
             T *= stepT
             iter += 1
-            emitter.emit(SIGNAL("commandPBarValue(int)"),
-                         int(-S.log(T)))  # signal for updating the progress bar
+            emitter.commandPBarValue.emit(int(-S.log(T)))  # signal for updating the progress bar
             # Check exit conditions
             if iter > maxiter:
                 print '\nMaximum number of iterations reached\n'
@@ -1270,7 +1267,7 @@
         if ireport is None: ireport = LM
         # do stabilisation
         if stabilisation > 0:
-            emitter.emit(SIGNAL("initCommandPBar(int,int)"), 0, int((
+            emitter.initCommandPBar.emit(0, int((
                                                                     stabilisation + LM) * factor))  # signal for setting up the progress bar
             self.MCMC_generate(LM=stabilisation, T=2.,
                                ireport=min(ireport, stabilisation),
@@ -1278,8 +1275,7 @@
                                factor=factor, iemit=iemit)
         if abort.abortRequested(): return  # check if we should abort
         # and do the proper BI
-        emitter.emit(SIGNAL("initCommandPBar(int,int)"),
-                     int(-stabilisation * factor), int(
+        emitter.initCommandPBar.emit(int(-stabilisation * factor), int(
                 LM * factor))  # signal for setting up the progress bar with an illusion of continuity
         self.MCMC_generate(LM=LM, T=2., ireport=ireport,
                            savehist=bool(savehist), NNRLA='auto', direct=False,
@@ -1365,7 +1361,7 @@
 				FORTRAN routines for large scale bound constrained optimization (1997),
 				ACM Transactions on Mathematical Software, Vol 23, Num. 4, pp. 550 - 560.
 		'''
-        emitter.emit(SIGNAL("initCommandPBar(int,int)"), 0,
+        emitter.initCommandPBar.emit(0,
                      5)  # signal for setting up the progress bar
         # start from a clean point
         self.confirm()
@@ -1391,8 +1387,7 @@
         itys = S.array(itys)
         # Try to do a (relatively fast) *unbounded* minimisation using a Levenberg-Marquardt algorithm
         if ireport: print "\nTrying a Levenberg-Marquardt (LMA) fit\n"
-        emitter.emit(SIGNAL("commandPBarValue(int)"),
-                     1)  # signal for updating the progress bar
+        emitter.commandPBarValue.emit(1)  # signal for updating the progress bar
         #		self.showreport(verbosity=1)
         if abort.abortRequested(): return  # check if we should abort
         myx, cov_x, infodict, mesg, ier = optimize.leastsq(
@@ -1435,8 +1430,7 @@
                                                          approx_grad=1,
                                                          bounds=minmax, m=10,
                                                          iprint=-1)
-            emitter.emit(SIGNAL("commandPBarValue(int)"),
-                         2)  # signal for updating the progress bar
+            emitter.commandPBarValue.emit(2)  # signal for updating the progress bar
             if ireport: print '#',
             # Do several runs of unbound simplex downhill till it converges
             warnflag, i = True, 0
@@ -1451,8 +1445,7 @@
                 warnflag = (ier != 1)
                 #				print mesg
                 if ireport: print '>',
-            emitter.emit(SIGNAL("commandPBarValue(int)"),
-                         3)  # signal for updating the progress bar
+            emitter.commandPBarValue.emit(3)  # signal for updating the progress bar
             # Do a second L-BFGS-B minimisation
             #			myx=S.where(myx<minmaxarray[:,0], minmaxarray[:,0], myx)
             #			myx=S.where(myx>minmaxarray[:,1], minmaxarray[:,1], myx)
@@ -1462,12 +1455,10 @@
                                                          approx_grad=1,
                                                          bounds=minmax, m=10,
                                                          iprint=-1)
-            emitter.emit(SIGNAL("commandPBarValue(int)"),
-                         4)  # signal for updating the progress bar
+            emitter.commandPBarValue.emit(4)  # signal for updating the progress bar
             if ireport: print '#\n'
         # Confirm and show the results
-        emitter.emit(SIGNAL("commandPBarValue(int)"),
-                     5)  # signal for updating the progress bar
+        emitter.commandPBarValue.emit(5)  # signal for updating the progress bar
         self.calculate_chi2(recalc=True)
         self.confirm()  # by doing this confirm, the .val of each parameter is copied to the .mean
         self.clearstats()
--- /home/carlos/src/PAScual/PAScual/PAScualGUI.py	(original)
+++ /home/carlos/src/PAScual/PAScual/PAScualGUI.py	(refactored)
@@ -100,14 +100,12 @@
         if callbackApply is None:
             self.BTApply.setDisabled(True)
         else:
-            QObject.connect(self.BTApply, SIGNAL("clicked()"),
-                            lambda: callbackApply(
+            self.BTApply.clicked.connect(lambda: callbackApply(
                                 self))  # it returns self to the callback
         if callbackAuto is None:
             self.BTAutoFill.setDisabled(True)
         else:
-            QObject.connect(self.BTAutoFill, SIGNAL("clicked()"),
-                            lambda: callbackAuto(self))
+            self.BTAutoFill.clicked.connect(lambda: callbackAuto(self))
         # set up validators
         for widget in [self.LEValue, self.LEMin,
                        self.LEMax]: widget.setValidator(QDoubleValidator(self))
@@ -274,113 +272,63 @@
         self.resultsdplist = []
 
         # Add connections here
-        QObject.connect(self.actionLoad_Spectra, SIGNAL("triggered()"),
-                        self.loadSpectra)
-        QObject.connect(self.actionAbout, SIGNAL("triggered()"), self.helpAbout)
-        QObject.connect(self.actionLicense, SIGNAL("triggered()"),
-                        self.showlicense)
-        QObject.connect(self.actionSum_Spectra, SIGNAL("triggered()"),
-                        self.sumspectra)
-        QObject.connect(self.actionTao_Eldrup_Calculator, SIGNAL("triggered()"),
-                        self.launchTEcalc)
-        QObject.connect(self.actionWhat_s_This, SIGNAL("triggered()"),
-                        lambda: QWhatsThis.enterWhatsThisMode())
-        QObject.connect(self.actionPlotFit, SIGNAL("triggered()"),
-                        self.onPlotFit)
-        QObject.connect(self.actionSimulate_spectrum, SIGNAL("triggered()"),
-                        self.createFakeSpectrum)
-        QObject.connect(self.actionCopy_Results_Selection,
-                        SIGNAL("triggered()"), self.copy_Results_Selection)
-        QObject.connect(self.actionShow_hide_Plot, SIGNAL("triggered()"),
-                        self.show_hidePlot)
-        QObject.connect(self.actionShowSpectraSel, SIGNAL("triggered()"),
-                        self.showSpectraList)
-        QObject.connect(self.actionManual, SIGNAL("triggered()"),
-                        self.showManual)
-        QObject.connect(self.actionSave_Output_as, SIGNAL("triggered()"),
-                        self.onSaveOutput_as)
-        QObject.connect(self.actionCheck_for_Updates, SIGNAL("triggered()"),
-                        lambda: self.check_for_Updates(force=True))
-        QObject.connect(self.actionParamWizard, SIGNAL("triggered()"),
-                        self.onParamWizard)
-        QObject.connect(self.actionOptions, SIGNAL("triggered()"),
-                        self.onOptions)
-        QObject.connect(self.actionSave_Spectra_as, SIGNAL("triggered()"),
-                        self.onSaveSpectra)
+        self.actionLoad_Spectra.triggered.connect(self.loadSpectra)
+        self.actionAbout.triggered.connect(self.helpAbout)
+        self.actionLicense.triggered.connect(self.showlicense)
+        self.actionSum_Spectra.triggered.connect(self.sumspectra)
+        self.actionTao_Eldrup_Calculator.triggered.connect(self.launchTEcalc)
+        self.actionWhat_s_This.triggered.connect(lambda: QWhatsThis.enterWhatsThisMode())
+        self.actionPlotFit.triggered.connect(self.onPlotFit)
+        self.actionSimulate_spectrum.triggered.connect(self.createFakeSpectrum)
+        self.actionCopy_Results_Selection.triggered.connect(self.copy_Results_Selection)
+        self.actionShow_hide_Plot.triggered.connect(self.show_hidePlot)
+        self.actionShowSpectraSel.triggered.connect(self.showSpectraList)
+        self.actionManual.triggered.connect(self.showManual)
+        self.actionSave_Output_as.triggered.connect(self.onSaveOutput_as)
+        self.actionCheck_for_Updates.triggered.connect(lambda: self.check_for_Updates(force=True))
+        self.actionParamWizard.triggered.connect(self.onParamWizard)
+        self.actionOptions.triggered.connect(self.onOptions)
+        self.actionSave_Spectra_as.triggered.connect(self.onSaveSpectra)
 
         #		QObject.connect(self.actionSaveResults,SIGNAL("triggered()"),self.onSaveResults)
-        QObject.connect(self.spectraTable, SIGNAL("doubleClicked(QModelIndex)"),
-                        self.onSpectraTableDoubleClick)
-        QObject.connect(self.spectraTable.selectionModel(), SIGNAL(
-            "selectionChanged(QItemSelection,QItemSelection)"),
-                        self.onspectraSelectionChanged)
-        QObject.connect(self.SBoxNcomp, SIGNAL("valueChanged(int)"),
-                        self.changeNcomp)
-        QObject.connect(self.roiPB, SIGNAL("clicked()"), self.setROI)
-        QObject.connect(self.BTpsperchannel, SIGNAL("clicked()"),
-                        self.setpsperchannel)
-        QObject.connect(self.showtauRB, SIGNAL("toggled(bool)"),
-                        self.onShowTauToggled)
-        QObject.connect(self.spectraModel, SIGNAL("selectionChanged"),
-                        self.changePPlot)
-        QObject.connect(self, SIGNAL("updateParamsView"),
-                        self.onUpdateParamsView)
-        QObject.connect(self.selectAllTB, SIGNAL("clicked()"),
-                        self.spectraModel.checkAll)
-        QObject.connect(self.selectNoneTB, SIGNAL("clicked()"),
-                        lambda: self.spectraModel.checkAll(False))
-        QObject.connect(self.selectMarkedTB, SIGNAL("clicked()"),
-                        self.onSelectMarked)
-        QObject.connect(self.removeSpectraTB, SIGNAL("clicked()"),
-                        self.onRemoveChecked)
-        QObject.connect(self.applycompsBT, SIGNAL("clicked()"),
-                        self.onApplyComps)
-        QObject.connect(self.applyAllParametersPB, SIGNAL("clicked()"),
-                        self.onApplyAllParameters)
-        QObject.connect(self.resetParametersPB, SIGNAL("clicked()"),
-                        self.onResetParameters)
-        QObject.connect(self.actionRegenerateSets, SIGNAL("triggered()"),
-                        lambda: self.onRegenerateSets(force=True))
-        QObject.connect(self.tabWidget, SIGNAL("currentChanged(int)"),
-                        self.onTabChanged)
-        QObject.connect(self, SIGNAL("regenerateSets"), self.onRegenerateSets)
-        QObject.connect(self.fitModeCB,
-                        SIGNAL("currentIndexChanged(const QString&)"),
-                        self.onFitModeCBChange)
-        QObject.connect(self.applyFitModeBT, SIGNAL("clicked()"),
-                        self.assignFitModes)
-        QObject.connect(self.goFitBT, SIGNAL("clicked()"), self.onGoFit)
-        QObject.connect(self.stopFitBT, SIGNAL("clicked()"), self.onStopFit)
-        QObject.connect(self.skipCommandBT, SIGNAL("clicked()"), self.onSkipFit)
-        QObject.connect(self.fitter, SIGNAL("endrun(bool)"),
-                        self.onFitterFinished)
+        self.spectraTable.doubleClicked.connect(self.onSpectraTableDoubleClick)
+        self.spectraTable.selectionModel().selectionChanged.connect(self.onspectraSelectionChanged)
+        self.SBoxNcomp.valueChanged.connect(self.changeNcomp)
+        self.roiPB.clicked.connect(self.setROI)
+        self.BTpsperchannel.clicked.connect(self.setpsperchannel)
+        self.showtauRB.toggled.connect(self.onShowTauToggled)
+        self.spectraModel.selectionChanged.connect(self.changePPlot)
+        self.updateParamsView.connect(self.onUpdateParamsView)
+        self.selectAllTB.clicked.connect(self.spectraModel.checkAll)
+        self.selectNoneTB.clicked.connect(lambda: self.spectraModel.checkAll(False))
+        self.selectMarkedTB.clicked.connect(self.onSelectMarked)
+        self.removeSpectraTB.clicked.connect(self.onRemoveChecked)
+        self.applycompsBT.clicked.connect(self.onApplyComps)
+        self.applyAllParametersPB.clicked.connect(self.onApplyAllParameters)
+        self.resetParametersPB.clicked.connect(self.onResetParameters)
+        self.actionRegenerateSets.triggered.connect(lambda: self.onRegenerateSets(force=True))
+        self.tabWidget.currentChanged.connect(self.onTabChanged)
+        self.regenerateSets.connect(self.onRegenerateSets)
+        self.fitModeCB.currentIndexChanged.connect(self.onFitModeCBChange)
+        self.applyFitModeBT.clicked.connect(self.assignFitModes)
+        self.goFitBT.clicked.connect(self.onGoFit)
+        self.stopFitBT.clicked.connect(self.onStopFit)
+        self.skipCommandBT.clicked.connect(self.onSkipFit)
+        self.fitter.endrun.connect(self.onFitterFinished)
         QObject.connect(self.fitter, SIGNAL("command_done(int)"), self.setPBar,
                         SLOT("setValue(int)"))
-        QObject.connect(self.commandsModel,
-                        SIGNAL("dataChanged(QModelIndex,QModelIndex)"),
-                        self.onFitModeEdit)
-        QObject.connect(self.hideResultsBT, SIGNAL("clicked()"),
-                        self.onHideResults)
-        QObject.connect(self.showResultsBT, SIGNAL("clicked()"),
-                        self.onShowResults)
-        QObject.connect(self.saveResultsBT, SIGNAL("clicked()"),
-                        self.onSaveResults)
-        QObject.connect(self.resultsTable, SIGNAL("doubleClicked(QModelIndex)"),
-                        self.onPlotFit)
-        QObject.connect(self.resultsFileSelectBT, SIGNAL("clicked()"),
-                        self.onResultsFileSelectBT)
-        QObject.connect(self.previousOutputCB,
-                        SIGNAL("currentIndexChanged(const QString&)"),
-                        self.onPreviousOutputCBChange)
-        QObject.connect(self.saveOutputBT, SIGNAL("clicked()"),
-                        self.onSaveOutput_as)
-        QObject.connect(self.saveFitmodeBT, SIGNAL("clicked()"),
-                        self.saveFitMode)
-        QObject.connect(self.loadParametersPB, SIGNAL("clicked()"),
-                        self.loadParameters)
-        QObject.connect(self.saveParametersPB, SIGNAL("clicked()"),
-                        self.saveParameters)
-        QObject.connect(self.plotFitBT, SIGNAL("clicked()"), self.onPlotFit)
+        self.commandsModel.dataChanged.connect(self.onFitModeEdit)
+        self.hideResultsBT.clicked.connect(self.onHideResults)
+        self.showResultsBT.clicked.connect(self.onShowResults)
+        self.saveResultsBT.clicked.connect(self.onSaveResults)
+        self.resultsTable.doubleClicked.connect(self.onPlotFit)
+        self.resultsFileSelectBT.clicked.connect(self.onResultsFileSelectBT)
+        self.previousOutputCB.currentIndexChanged.connect(self.onPreviousOutputCBChange)
+        self.saveOutputBT.clicked.connect(self.onSaveOutput_as)
+        self.saveFitmodeBT.clicked.connect(self.saveFitMode)
+        self.loadParametersPB.clicked.connect(self.loadParameters)
+        self.saveParametersPB.clicked.connect(self.saveParameters)
+        self.plotFitBT.clicked.connect(self.onPlotFit)
 
         # Restore last session Window state
         size = self.settings.value("MainWindow/Size",
@@ -435,8 +383,7 @@
     def createParamWizard(self):
         from ParamWizard import ParamWizard
         self.paramWizard = ParamWizard(None)
-        self.connect(app, SIGNAL('focusChanged(QWidget *, QWidget *)'),
-                     self.paramWizard.ROIPage.ROIsel.onFocusChanged)  # manage the focus events (needed for mouse selection in ROI)
+        app.focusChanged.connect(self.paramWizard.ROIPage.ROIsel.onFocusChanged)  # manage the focus events (needed for mouse selection in ROI)
 
     def createOpenFilesDlg(self):
         # General OpenFile Dialog (it is never closed, just hidden)
@@ -598,10 +545,8 @@
             self.plotfitDlg.layout.addWidget(self.plotfitDlg.textTE)
             self.plotfitDlg.layout.addLayout(layout2)
             self.plotfitDlg.setLayout(self.plotfitDlg.layout)
-            QObject.connect(self.plotfitDlg.prevPB, SIGNAL("clicked()"),
-                            lambda: self.plotfit(self.dprow - 1))
-            QObject.connect(self.plotfitDlg.nextPB, SIGNAL("clicked()"),
-                            lambda: self.plotfit(self.dprow + 1))
+            self.plotfitDlg.prevPB.clicked.connect(lambda: self.plotfit(self.dprow - 1))
+            self.plotfitDlg.nextPB.clicked.connect(lambda: self.plotfit(self.dprow + 1))
         else:
             self.plotfitDlg.fitplot.reset()
             self.plotfitDlg.resplot.reset()
@@ -839,16 +784,13 @@
         '''Restores a the self.fitter object and its connections (use in case of having terminated the fitter thread)
 		abortobject is the handler containing the abortRequested() to which we assign the fitter.isStopped()'''
         self.fitter = PCP.fitter(self)
-        QObject.connect(self.fitter, SIGNAL("endrun(bool)"),
-                        self.onFitterFinished)
+        self.fitter.endrun.connect(self.onFitterFinished)
         QObject.connect(self.fitter, SIGNAL("command_done(int)"), self.setPBar,
                         SLOT("setValue(int)"))
-        QObject.connect(emitter, SIGNAL("initCommandPBar(int,int)"),
-                        self.commandPBar.setRange)
+        emitter.initCommandPBar.connect(self.commandPBar.setRange)
         QObject.connect(emitter, SIGNAL("commandPBarValue(int)"),
                         self.commandPBar, SLOT("setValue(int)"))
-        QObject.connect(emitter, SIGNAL("teeOutput"),
-                        self.outputTE.insertPlainText)
+        emitter.teeOutput.connect(self.outputTE.insertPlainText)
         abortobject.abortRequested = form.fitter.isStopped  # reassign the  abortRequested() method from the abort object defined in PAScual
 
     def onSkipFit(self):
@@ -1014,7 +956,7 @@
                                QVariant(self.openFilesDlg.selectedFilter()))
 
     def onTabChanged(self, tabindex):
-        if tabindex == 1: self.emit(SIGNAL("regenerateSets"), False)
+        if tabindex == 1: self.regenerateSets.emit(False)
 
     def onRegenerateSets(self, force=False):
         # only regenerate if there is a chance of change (or if we explicitely force it)
@@ -1070,7 +1012,7 @@
         # mark that the sets might be dirty now
         self.dirtysets = True
         # signal recalculation of sets
-        self.emit(SIGNAL("regenerateSets"), False)
+        self.regenerateSets.emit(False)
 
     def sumspectra(self):
         '''Sums the checked spectra and offers to save them. It inserts the sum in the list'''
@@ -1105,8 +1047,7 @@
         self.spectraModel.insertRows(position=None, rows=1, dps=[dpsum])
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.PSPC)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         return True
 
     def onSpectraTableDoubleClick(self, index):
@@ -1121,12 +1062,11 @@
         selrows = self.spectraTable.selectionModel().selectedRows()
         nselrows = len(selrows)
         if nselrows == 0:
-            self.emit(SIGNAL("updateParamsView"), discretepals())
+            self.updateParamsView.emit(discretepals())
         elif nselrows == 1:
-            self.emit(SIGNAL("updateParamsView"),
-                      self.spectraModel.data(selrows[0], role=Qt.UserRole))
+            self.updateParamsView.emit(self.spectraModel.data(selrows[0], role=Qt.UserRole))
         else:
-            self.emit(SIGNAL("updateParamsView"), None)
+            self.updateParamsView.emit(None)
 
     def onShowTauToggled(self, checked):
         self.compModel.showtau = checked
@@ -1151,8 +1091,7 @@
             dp.psperchannel = float(self.LEpsperchannel.text())
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.PSPC)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         # mark that the sets might be dirty now
         self.dirtysets = True
         return True
@@ -1189,8 +1128,7 @@
         selected, indexes = self.spectraModel.getselectedspectra()
         if selected == []: return
         ROIselector = ROISelectorDialog(self, selected, "ROI")
-        ROIselector.connect(app, SIGNAL('focusChanged(QWidget *, QWidget *)'),
-                            ROIselector.onFocusChanged)
+        app.focusChanged.connect(ROIselector.onFocusChanged)
         if ROIselector.exec_():
             for dp, bgroi in zip(selected, ROIselector.roilist): dp.roi = bgroi
             self.spectraTable.resizeColumnToContents(STMV.ROI)
@@ -1220,8 +1158,7 @@
         for idx in indexes:
             idx1 = self.spectraModel.index(idx.row(), 0)
             idx2 = self.spectraModel.index(idx.row(), ncol)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx1, idx2)
+            self.spectraModel.dataChanged.emit(idx1, idx2)
         #		print "DEBUG:",fp.name, fp.val, fp.minval, fp.maxval, fp.free, type(fp), caller._fpkey
         # mark that the sets might be dirty now
         self.dirtysets = True
@@ -1292,8 +1229,7 @@
         # notify of the changes
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.COMP)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         return True
 
     def onApplyAllParameters(self):
@@ -1361,8 +1297,7 @@
         self.onUpdateParamsView(dp)  # update what is shown
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.C0)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         self.statusbar.showMessage(
             "AutoOffset Finished (with %i warnings)" % nerror, 0)
 
@@ -1382,8 +1317,7 @@
                 return  # abort the autobackground
         # launch the dialog in modal mode and execute some code if accepted
         BGselector = ROISelectorDialog(self, selected, "Background")
-        BGselector.connect(app, SIGNAL('focusChanged(QWidget *, QWidget *)'),
-                           BGselector.onFocusChanged)
+        app.focusChanged.connect(BGselector.onFocusChanged)
         if BGselector.exec_():
             for dp, bgroi in zip(selected, BGselector.roilist):
                 val = dp.exp[bgroi].mean()
@@ -1396,8 +1330,7 @@
             # Notify of the changes
             for idx in indexes:
                 idx = self.spectraModel.index(idx.row(), STMV.BG)
-                self.spectraModel.emit(
-                    SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+                self.spectraModel.dataChanged.emit(idx, idx)
             self.onUpdateParamsView(dp)
 
     def changePPlot(self, dp, index=None, replot=True):
@@ -1470,7 +1403,7 @@
             # mark that the sets might be dirty now
             self.dirtysets = True
             # signal regeneration of sets
-            self.emit(SIGNAL("regenerateSets"), False)
+            self.regenerateSets.emit(False)
             self.statusbar.showMessage("Done", 0)
             # Launch Wizard
             if self.options.autoWizardOnLoad:
@@ -1702,8 +1635,7 @@
             dp.bg.forcelimits()
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.BG)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         self.onUpdateParamsView(dp)
         # c0
         self.autoc0(self.c0FitparWidget)
@@ -1726,15 +1658,14 @@
         # notify of the changes
         for idx in indexes:
             idx = self.spectraModel.index(idx.row(), STMV.COMP)
-            self.spectraModel.emit(
-                SIGNAL("dataChanged(QModelIndex,QModelIndex)"), idx, idx)
+            self.spectraModel.dataChanged.emit(idx, idx)
         self.compModel.reset()
         # select the last of the checked spectra (so that the parameters are shown)
         self.spectraTable.clearSelection()
         self.spectraTable.selectRow(indexes[-1].row())
         # recalculate sets
         self.dirtysets = True
-        self.emit(SIGNAL("regenerateSets"), False)
+        self.regenerateSets.emit(False)
 
     def loadParameters(self):
         '''uses a dp to fill the parameters. If no spectra si given, it asks to load a file which is expected to contain a pickled discretepals'''
@@ -1878,11 +1809,10 @@
     form = PAScualGUI()
     form.show()
 
-    QObject.connect(emitter, SIGNAL("initCommandPBar(int,int)"),
-                    form.commandPBar.setRange)
+    emitter.initCommandPBar.connect(form.commandPBar.setRange)
     QObject.connect(emitter, SIGNAL("commandPBarValue(int)"), form.commandPBar,
                     SLOT("setValue(int)"))
-    QObject.connect(emitter, SIGNAL("teeOutput"), form.outputTE.insertPlainText)
+    emitter.teeOutput.connect(form.outputTE.insertPlainText)
     abort.abortRequested = form.fitter.isStopped  # reassign the  abortRequested() method from the abort object defined in PAScual
 
     sys.exit(app.exec_())
--- /home/carlos/src/PAScual/PAScual/PASoptions.py	(original)
+++ /home/carlos/src/PAScual/PAScual/PASoptions.py	(refactored)
@@ -58,12 +58,9 @@
         self.BI_reportLE.setValidator(QDoubleValidator(self))
         self.seedLE.setValidator(QIntValidator(self))
         # connections
-        self.connect(self.buttonBox, SIGNAL("clicked(QAbstractButton *)"),
-                     self.onclicked)
-        self.connect(self.manualFilePB, SIGNAL("clicked()"),
-                     self.onChangeManualFile)
-        self.connect(self.workDirectoryPB, SIGNAL("clicked()"),
-                     self.onChangeWorkDirectory)
+        self.buttonBox.clicked.connect(self.onclicked)
+        self.manualFilePB.clicked.connect(self.onChangeManualFile)
+        self.workDirectoryPB.clicked.connect(self.onChangeWorkDirectory)
 
         # set options
         self.reset()
--- /home/carlos/src/PAScual/PAScual/ParamWizard.py	(original)
+++ /home/carlos/src/PAScual/PAScual/ParamWizard.py	(refactored)
@@ -31,14 +31,10 @@
     def __init__(self, parent=None):
         super(AddCompsWidget, self).__init__(parent)
         self.setupUi(self)
-        self.connect(self.addpPsBT, SIGNAL('clicked()'),
-                     lambda: self.addComp(125))
-        self.connect(self.addDirectBT, SIGNAL('clicked()'),
-                     lambda: self.addComp(400))
-        self.connect(self.addoPsBT, SIGNAL('clicked()'),
-                     lambda: self.addComp(2000))
-        self.connect(self.addCustomBT, SIGNAL('clicked()'),
-                     lambda: self.addComp(self.customTauSB.value()))
+        self.addpPsBT.clicked.connect(lambda: self.addComp(125))
+        self.addDirectBT.clicked.connect(lambda: self.addComp(400))
+        self.addoPsBT.clicked.connect(lambda: self.addComp(2000))
+        self.addCustomBT.clicked.connect(lambda: self.addComp(self.customTauSB.value()))
 
     # 		self.connect(self.addCustomBT,SIGNAL('clicked()'), self.getComps)
     def addComp(self, tau):
@@ -290,7 +286,6 @@
     #  	form2.show()
 
     form = ParamWizard(None, selected)
-    form.connect(app, SIGNAL('focusChanged(QWidget *, QWidget *)'),
-                 form.ROIPage.ROIsel.onFocusChanged)  # manage the focus events (needed for mouse selection in ROI)
+    app.focusChanged.connect(form.ROIPage.ROIsel.onFocusChanged)  # manage the focus events (needed for mouse selection in ROI)
     form.show()
     sys.exit(app.exec_())
--- /home/carlos/src/PAScual/PAScual/PlotGraphWidget.py	(original)
+++ /home/carlos/src/PAScual/PAScual/PlotGraphWidget.py	(refactored)
@@ -94,9 +94,7 @@
         grid.attach(self)
         grid.setPen(Qt.QPen(Qt.Qt.black, 0, Qt.Qt.DotLine))
         # Connect clicks on toolbar to toggleVisibility
-        self.connect(self,
-                     Qt.SIGNAL("legendClicked(QwtPlotItem*)"),
-                     self.toggleVisibility)
+        self.legendClicked.connect(self.toggleVisibility)
         # replot
         self.replot()
         # set zoomer
@@ -119,8 +117,7 @@
         # 		self.connect(self.picker, Qt.SIGNAL('selected(const QwtDoublePoint&)'), pointselected)
         self.setContextMenuPolicy(Qt.Qt.ActionsContextMenu)
         self._exportPdfAction = Qt.QAction("Export plot to PDF...", self)
-        self.connect(self._exportPdfAction, Qt.SIGNAL("triggered()"),
-                     self.exportPdf)
+        self._exportPdfAction.triggered.connect(self.exportPdf)
         self.addAction(self._exportPdfAction)
 
     def attachCurve(self, x, y, name='', pen=None, style="Lines"):
@@ -238,8 +235,7 @@
         # 		self.connect(self.picker, Qt.SIGNAL('selected(const QwtDoublePoint&)'), pointselected)
         self.setContextMenuPolicy(Qt.Qt.ActionsContextMenu)
         self._exportPdfAction = Qt.QAction("Export plot to PDF...", self)
-        self.connect(self._exportPdfAction, Qt.SIGNAL("triggered()"),
-                     self.exportPdf)
+        self._exportPdfAction.triggered.connect(self.exportPdf)
         self.addAction(self._exportPdfAction)
 
     def attachCurve(self, x, y, name='', pen=None):
--- /home/carlos/src/PAScual/PAScual/ROISelectorDlg.py	(original)
+++ /home/carlos/src/PAScual/PAScual/ROISelectorDlg.py	(refactored)
@@ -93,18 +93,13 @@
         self.resetSelected(selected)
 
         # Connect signals to slots:
-        QObject.connect(self.refspectrumCB, SIGNAL("currentIndexChanged(int)"),
-                        self.onrefspectraChange)
+        self.refspectrumCB.currentIndexChanged.connect(self.onrefspectraChange)
         self.connect(self.buttonBox, SIGNAL("rejected()"), self,
                      SLOT("reject()"))
-        self.connect(self.buttonBox, SIGNAL("accepted()"), self.checkAndApply)
-        self.connect(self.lowerlimRelCB, SIGNAL("stateChanged(int)"),
-                     self.onlowerlimRelChange)
-        self.connect(self.upperlimRelCB, SIGNAL("stateChanged(int)"),
-                     self.onupperlimRelChange)
-        self.connect(self.plotarea.picker,
-                     SIGNAL('selected(const QwtDoublePoint&)'),
-                     self.onselection)
+        self.buttonBox.accepted.connect(self.checkAndApply)
+        self.lowerlimRelCB.stateChanged.connect(self.onlowerlimRelChange)
+        self.upperlimRelCB.stateChanged.connect(self.onupperlimRelChange)
+        self.plotarea.picker.selected.connect(self.onselection)
 
         self.selectiondestination = self.upperlimRelCB
 
@@ -227,8 +222,7 @@
     selected = [dp2, dp3]
     # initialisation
     demo = ROISelectorDialog(selected=selected)
-    demo.connect(app, SIGNAL('focusChanged(QWidget *, QWidget *)'),
-                 demo.onFocusChanged)
+    app.focusChanged.connect(demo.onFocusChanged)
     demo.exec_()
     demo.resetSelected([dp3, dp4])
     demo.exec_()
--- /home/carlos/src/PAScual/PAScual/SpectraTableMV.py	(original)
+++ /home/carlos/src/PAScual/PAScual/SpectraTableMV.py	(refactored)
@@ -152,9 +152,9 @@
             column = index.column()
             if column == SEL:
                 dp.selected = not dp.selected
-                self.emit(SIGNAL("selectionChanged"), dp,
+                self.selectionChanged.emit(dp,
                           index)  # this is a custom signal to warn that the 'hard' selection changed
-            self.emit(SIGNAL("dataChanged(QModelIndex,QModelIndex)"), index,
+            self.dataChanged.emit(index,
                       index)
             return True
         return False
@@ -168,7 +168,7 @@
         for row in range(rows):
             # 			dp=discretepals(name=u"new")
             self.spectra.insert(position + row, dps[row])
-            self.emit(SIGNAL("selectionChanged"), dps[row],
+            self.selectionChanged.emit(dps[row],
                       self.index(position + row, SEL))
         self.endInsertRows()
         return True
@@ -194,8 +194,8 @@
         for dp, idx in zip(self.spectra, indexlist):
             if dp.selected != value:
                 dp.selected = value
-                self.emit(SIGNAL("selectionChanged"), dp, idx)
-        self.emit(SIGNAL("dataChanged(QModelIndex,QModelIndex)"), indexlist[0],
+                self.selectionChanged.emit(dp, idx)
+        self.dataChanged.emit(indexlist[0],
                   indexlist[-1])
 
     def removeChecked(self):
@@ -203,7 +203,7 @@
         for dp in self.spectra:
             if dp.selected:
                 dp.selected = False
-                self.emit(SIGNAL("selectionChanged"), dp, None)
+                self.selectionChanged.emit(dp, None)
             else:
                 temp.append(dp)
         self.spectra = temp
@@ -275,10 +275,10 @@
         mainLayout.addWidget(self.allBT, 3, 1)
         self.setLayout(mainLayout)
 
-        QObject.connect(self.addBT, SIGNAL("clicked()"), self.onAdd)
-        QObject.connect(self.remBT, SIGNAL("clicked()"), self.onRem)
-        QObject.connect(self.dataBT, SIGNAL("clicked()"), self.onData)
-        QObject.connect(self.allBT, SIGNAL("clicked()"), self.model.checkAll)
+        self.addBT.clicked.connect(self.onAdd)
+        self.remBT.clicked.connect(self.onRem)
+        self.dataBT.clicked.connect(self.onData)
+        self.allBT.clicked.connect(self.model.checkAll)
         self.table.resizeColumnsToContents()
         # 		self.tree.resizeColumnsToContents()
         self.table.setShowGrid(False)
--- /home/carlos/src/PAScual/PAScual/TEcalcGUI.py	(original)
+++ /home/carlos/src/PAScual/PAScual/TEcalcGUI.py	(refactored)
@@ -36,9 +36,8 @@
             [self.actionCopy_Results_Selection])  # context menu
 
         # connections
-        QObject.connect(self.CalculatePB, SIGNAL("clicked()"), self.onCalculate)
-        QObject.connect(self.actionCopy_Results_Selection,
-                        SIGNAL("triggered()"), self.copy_Results_Selection)
+        self.CalculatePB.clicked.connect(self.onCalculate)
+        self.actionCopy_Results_Selection.triggered.connect(self.copy_Results_Selection)
 
     def onCalculate(self):
         '''Launches the calculation'''
